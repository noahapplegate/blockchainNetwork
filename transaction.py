from Crypto.Hash import SHA256
from Crypto.Signature import pkcs1_15
from Crypto.PublicKey import RSA
from typing import List
import copy


class TXOutput:
    """
    Output of a transaction (amount, public key of recipient)
    ...
    Attributes
    ----------
    amount : int
        Amount of coin being spent in this output
    owner : bytes
        Public key of the owner of this output.
        Generated by a Crypto.PublicKey.RSA object.

    Methods
    -------
    __init__(amount, owner)
        Initializes the TXOutput with the amount being sent and the
        public key of the recipient
    """
    def __init__(self, amount: int, owner: bytes):
        self.amount = amount
        self.owner = owner


class TXInput:
    """
    Input of a coin transaction (where the coin is coming from)
    ...
    Attributes
    ----------
    prev_tx : bytes
        ID of the Transaction where the output being spent resides
    output_ind : int
        Index within the specified Transaction of the output being spent

    Methods
    -------
    __init__(prev_tx, output_ind)
        Initializes the TXInput with the previous Transaction header and
        the index of the output being spent within that Transaction
    """
    def __init__(self, prev_tx: bytes, output_ind: int):
        self.prev_tx = prev_tx
        self.output_ind = output_ind


class Transaction:
    """
    Represents coin transactions (receiving and sending)

    The sender of the Transaction provides their secret key along with
    Transaction data to create a signature on that Transaction data.
    The signature along with the sender's public key are stored so anyone
    who receives this Transaction can verify the Transaction data has not
    been tampered with.
    ...
    Attributes
    ----------
    inputs : List[TXInput]
        UTXOs being spent in the transaction
    outputs : List[TXOutput]
        Describes how the coin is being spent
    sender_public_key : bytes
        Public key of the sender of this transaction. Used to verify
        the signature on the transaction.
    signature : Crypto.Signature.pkcs1_15
        Digital signature created using the sender's secret key
    verifier : Crypto.Signature.pkcs1_15
        Used for verifying the signature on the Transaction.
        Wraps the Crypto.Publickey.RSA object passed in the constructor so the
        object only needs to hold the bytes of the sender's public key and not
        the entire RSA key object.

    Methods
    -------
    __init__(inputs, outputs, sender_private_key, sender_public_key)
        Initializes the inputs and outputs of the transaction and generates
        a new transaction id. Uses the sender_key_pair to get the sender's
        secret key which is used to generate a signature and stores the
        sender's public key.

    get_txid() -> bytes
        Gets the SHA256 of the Transaction data.

    generate_txid() -> Crypto.Hash.SHA256
        Generate the Transaction ID for this transaction by hashing Transaction
        data. Only for use in the verify_signature method.
        Use get_txid to get the header as bytes.

    verify_signature() -> bool
        Verifies the stored signature against the generated Transaction ID to
        ensure Transaction data has not been tampered with since initialization

    """
    def __init__(self, inputs: List[TXInput], outputs: List[TXOutput],
                 sender_private_key: bytes, sender_public_key: bytes):
        # Assign inputs, outputs, sender_public_key
        # Perform deep copies on inputs and outputs
        self.inputs = copy.deepcopy(inputs)
        self.outputs = copy.deepcopy(outputs)
        self.sender_public_key = sender_public_key

        # Create a digital signature for the transaction data
        sender_secret_key_obj = RSA.importKey(sender_private_key)
        sender_public_key_obj = RSA.importKey(sender_public_key)
        self.verifier = pkcs1_15.new(sender_public_key_obj)

        # Sign the transaction data with the sender's secret key
        self.signature = pkcs1_15.new(sender_secret_key_obj).sign(self.generate_txid())

    def get_txid(self) -> bytes:
        return self.generate_txid().digest()

    def generate_txid(self):
        tx_hash = SHA256.new()
        for tx_in in self.inputs:
            tx_hash.update(tx_in.prev_tx + tx_in.output_ind.to_bytes(4, 'big'))
        for tx_out in self.outputs:
            tx_hash.update(tx_out.amount.to_bytes(4, 'big') + tx_out.owner)
        return tx_hash

    def verify_signature(self) -> bool:
        try:
            self.verifier.verify(self.generate_txid(), self.signature)
            return True
        except (ValueError, TypeError):
            return False


